/*
*    This program is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    This program is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*    ANDERSON C. SILVA				OCTOBER 2019
*/

#include "include/dml_operators.h"
#include "include/viz.h"
#include "engine/include/predictor.h"
#include <malloc.h>

#include <../core/include/util.h>
#include <core/include/time_evaluator.h>

using namespace std;

Predict::Predict(OperationPtr operation,
            ConfigurationManagerPtr configurationManager,
            QueryDataManagerPtr queryDataManager,
            MetadataManagerPtr metadataManager, StorageManagerPtr storageManager,
            EnginePtr engine) :
    EngineOperator(operation, configurationManager, queryDataManager, metadataManager, storageManager, engine){

    SET_TARS(_inputTAR, _outputTAR);
    SET_GENERATOR(_generator, _inputTAR->GetName());
    SET_GENERATOR(_outputGenerator, _outputTAR->GetName());
    SET_INT_CONFIG_VAL(_numSubtars, MAX_PARA_SUBTARS);
}

SavimeResult Predict::GenerateSubtar(SubTARIndex subtarIndex){


    //Getting current subTAR
    auto subtar = _generator->GetSubtar(subtarIndex);
    if(subtar == nullptr){
        return SAVIME_SUCCESS;
    }

    auto predictionModel = this->getModel();
    auto predictedValues = this->getPredictions(subtar, predictionModel);
    auto newSubtar = this->createNewSubtar(predictedValues, predictionModel);
    this->sendOutputSubtar(subtarIndex, newSubtar);

    //Must return success
    return SAVIME_SUCCESS;
}

vector<string> Predict::getPredictions(SubtarPtr subtar, PredictionModel *model) {
    auto *p = new Predictor(model, _storageManager, _configurationManager);
    vector<string> predictedValues = p->getPredictions(subtar);
    delete(p);

    //Returns the allocated memory to the OS
    malloc_trim(0);
    return predictedValues;
}

SubtarPtr Predict::createNewSubtar(vector<string> predictedValues, PredictionModel *predictionModel) {
    //Create new subtar
    SubtarPtr newSubtar = make_shared<Subtar>();

    auto ds = _storageManager->Create(DOUBLE, predictedValues);
    auto outputAttributeName = predictionModel->getOutputAttributeList().front().first;
    auto outputDimList   = predictionModel->getOutputDimensionList();

    //output TAR is generated by the current operator
    TARPtr outputTAR = _operation->GetResultingTAR();

    int adjacency = 1;
    int stride = 0;
    auto d = outputTAR->GetDimensions().rbegin();
    do{
        auto dim = outputDimList.back();
        stride = (savime_size_t ) (dim->GetUpperBound() - dim->GetLowerBound() ) * adjacency;
        RealIndex lower_bound = dim->GetLowerBound(), upper_bound = dim->GetUpperBound();
        DimSpecPtr newDimSpec = std::make_shared<DimensionSpecification>(
                UNSAVED_ID, *d, lower_bound, upper_bound-1, stride, adjacency);//lower and up bound, stride and adjacency
        newSubtar->AddDimensionsSpecification(newDimSpec);
        adjacency =  stride;
        outputDimList.pop_back();
        d++;
    }while(not outputDimList.empty());
    newSubtar->AddDataSet(outputAttributeName, ds);
    return newSubtar;
}

PredictionModel* Predict::getModel() {
    string modelName = _operation->GetParametersByName("model_name")->literal_str;
    auto predictionModel = new PredictionModel(modelName);
    return predictionModel;

}

void Predict::sendOutputSubtar(SubTARIndex subtarIndex, SubtarPtr newSubtar) {
    //Setting output subTAR equal to the input subTAR
    _outputGenerator->AddSubtar(subtarIndex, newSubtar);
    _generator->TestAndDisposeSubtar(subtarIndex);
}
