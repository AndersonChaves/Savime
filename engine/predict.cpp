/*
*    This program is free software: you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation, either version 3 of the License, or
*    (at your option) any later version.
*
*    This program is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*    ANDERSON C. SILVA				OCTOBER 2019
*/

#include "include/dml_operators.h"
#include "include/viz.h"
#include "engine/include/predictor.h"
#include <malloc.h>

Predict::Predict(OperationPtr operation,
            ConfigurationManagerPtr configurationManager,
            QueryDataManagerPtr queryDataManager,
            MetadataManagerPtr metadataManager, StorageManagerPtr storageManager,
            EnginePtr engine) :
    EngineOperator(operation, configurationManager, queryDataManager, metadataManager, storageManager, engine){

    SET_TARS(_inputTAR, _outputTAR);
    SET_GENERATOR(_generator, _inputTAR->GetName());
    SET_GENERATOR(_outputGenerator, _outputTAR->GetName());
    SET_INT_CONFIG_VAL(_numSubtars, MAX_PARA_SUBTARS);

}

SavimeResult Predict::GenerateSubtar(SubTARIndex subtarIndex){
    TARPtr inputTAR = _inputTAR;
    string modelName = _operation->GetParametersByName("model_name")->literal_str;

    auto list = _operation->GetParameters();

    //output TAR is generated by the current operator
    TARPtr outputTAR = _operation->GetResultingTAR();

    //Getting current subTAR
    auto subtar = _generator->GetSubtar(subtarIndex);

    //If subtar is null, return
    if(subtar == nullptr){
        return SAVIME_SUCCESS;
    }

    //Obtaining Predictions
    auto *p = new Predictor(new PredictionModel(modelName));
    vector<string> predictedValues = p->getPredictions(subtar, _storageManager, modelName);
    delete(p);
    //Returns the allocated memory to the OS
    malloc_trim(0);

    //Create new subtar
    SubtarPtr newSubtar = make_shared<Subtar>();

    auto ds = _storageManager->Create(DOUBLE, predictedValues);
    newSubtar->AddDataSet("op_result", ds);

    auto d = outputTAR->GetDimensions().front();

    auto model = new PredictionModel(modelName);
    auto outputDim = model->getOutputDimensionList().front();
    auto outputAttribute = model->getOutputAttributeList().front();
    delete(model);

    RealIndex lower_bound = outputDim->GetLowerBound(), upper_bound = outputDim->GetUpperBound();
    savime_size_t stride = (savime_size_t ) (outputDim->GetUpperBound() - outputDim->GetLowerBound() + 1),
        adjacency = 1;
    DimSpecPtr newDimSpec = std::make_shared<DimensionSpecification>(
        UNSAVED_ID, d, lower_bound, upper_bound, stride, adjacency);//lower and up bound, stride and adjacency

    newSubtar->AddDimensionsSpecification(newDimSpec);

    //Setting output subTAR equal to the input subTAR
    _outputGenerator->AddSubtar(subtarIndex, newSubtar);
    _generator->TestAndDisposeSubtar(subtarIndex);

    //Must return success
    return SAVIME_SUCCESS;
}